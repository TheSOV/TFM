per_resource_research:
  description: >
    **Start Here**  
    • If a **<feedback>** block is present, fix those items first. Feedback 
    is mandatory.

    **Goal**  
    Research and design a production-grade Kubernetes manifest for each of the resources  
    **<resources>** referenced in the **<blackboard>**.  

    The deliverable must anticipate and mitigate the most common volume-related
    failures—e.g. read-only mounts, missing PersistentVolumeClaims (PVCs),
    ownership/permission mismatches, ports, configmaps mathcing the configuation of the cluster
    with resptect to the image being used or ephemeral storage used for
    stateful data, and include, if applies, the specific information about the image being used
    that covers the previous research and any other image-specific data required.
    The final document should be *nearly deployable*,
    needing only environment-specific substitutions (namespaces, storage
    classes, resource sizes, etc.).

    **Methodology**

    1. Read the <blackboard>

        Note the workload type (Deployment, StatefulSet, Job, etc.).

        Capture every container image and its tag or digest.

        List paths the app needs to read or write (logs, data, cache, config).

        Record other hints that affect storage: ports, probes, resource requests.

    2. Check the Image & Specs

        Look up the image’s docs to see which folders must be writable.

        Decide which volume fields you really need: volumes, volumeMounts, volumeClaimTemplates, subPath, access modes.

        Keep defaults unless a change is truly required.

        Prefer:

            Non-root users (runAsUser, runAsNonRoot).

            Ephemeral or dynamic/private ports (> 1024).

            allowPrivilegeEscalation: false whenever possible.

        Never rely on “quick fixes” (e.g., a BusyBox init-container just to chown).

        In case that you need to add capabilities to the container, remember to drop unused 
        capabilities and set allowPrivilegeEscalation: true.

    3. Avoid Common Mistakes

        Don’t write into ConfigMap or Secret mounts.

        Don’t share a ReadWriteOnce PVC across replicas.

        Make sure every volumeMount.name exists in volumes.

        Don’t mount over a directory the image already populates.

        Give non-root containers write access or a scratch emptyDir.

        Keep port numbers consistent across Deployment, Service, Ingress, ConfigMap.

    4. Apply Best Practices
    
        - Volume type	emptyDir for scratch, PVC for persistent data, projected for bundled config.
        - Access mode	Match the app’s real needs; default to RWO unless shared writes are required.
        - Permissions	Use fsGroup or let the image own the path; avoid manual chmod.
        - Resources	Set CPU & memory requests/limits for every container.
        - Security	Define securityContext, seccompProfile, and drop unused capabilities.
        - API versions	Use only current, non-deprecated APIs.

    5. Draft the YAML

        Start with the minimal skeleton for the workload kind.

        Add volumes and volumeMounts; comment each one.

        Set securityContext (UID/GID, readOnlyRootFilesystem, etc.).

        Add ConfigMaps/Secrets as read-only (use stringData for Secrets).

        Map any well-known port (e.g., 1 - 1024) to an ephemeral or dynamic/private container port (e.g., 8080) and expose it through the Service.
        Remember that well-known ports required additional permissions to bind to, and to add permissions you must set 
        allowPrivilegeEscalation: true.

        Target environment: single-node kind cluster.

    <Important>
    - During this step, yaml files has been created yet, so do not use the yaml_read tool.
    - Ensure that you research about the correct resource, given in the <resources> block.
    - Ensure that each file contains only the elements and configurations that are relative to it.
    Never mix two resources in the same yaml file during the planification steps. Ensure that 
    each file is self-contained and clear.
    - Ensure to use the available information about the image being used, given in the
    <blackboard> block, such as image name, ports, users, users groups, version, etc.
    - Remember labels cant include whitespace, so use _ or - instead of space.
    - Your focus is to create a minimal, secure and production ready plan. Focus on the k8s 
       implementation, and the minimal image configuration required to implement it.
    - Take in count that we are working on a single node kind cluster.
    </Important>

    The resources you must analyze are:
    <resources>
    {resources}
    </resources>

    <blackboard>
    {blackboard}
    </blackboard>

    <feedback>
    {feedback}
    </feedback>
  expected_output: >
    Clear Instructions for the “Resources → Docs” Output

    1. Format

      Return **one JSON array**.  
      Each element is an object with three keys:

        {
          "title": "<exact title from <resources>>",
          "namespace": "<same namespace from <resources>>",
          "description": "<see Section 2>"
        }

      (Different namespaces are allowed but rare—only change them when truly required.)

    2. What Goes in description

      - **Volumes** – Why each volume type/access mode was chosen; how it ties to
        `securityContext`; pitfalls avoided.  Prefer to use non-root users to allow
        the container to write to the volume when possible using 
        `fsGroup` and `readOnlyRootFilesystem:True`.
      - **Security context** – Reasoning for `runAsUser`, `fsGroup`,
        `readOnlyRootFilesystem`, `allowPrivilegeEscalation`, `capabilities`,
        `seccompProfile`, `automountServiceAccountToken`.  
      - **Ports** – Why an ephemeral or dynamic/private container port was picked and
        how the Service maps it to the original port. Always prefer ephemeral or dynamic/private ports
        over well-known ports if possible.
      - **ConfigMaps & Secrets** – Alignment with image needs and the security
        model.  
      - **Operator tips** – Storage-class hints, clean-up rules, monitoring
        hooks.  
      - **YAML draft** – Nearly deployable manifest:  
          • Valid once TODOs are filled.  
          • Volume names match mounts.  
          • Read-only vs read-write flags shown.  
          • Inline comments explain *why* each part exists (ports included).

    3. Keep It Clean

      - Prefer non-root users and ephemeral or dynamic/private ports.  
      - Use solid practices, not ad-hoc fixes.  
      - Stick to current, non-deprecated API versions.

    4. Notes
      - readOnlyRootFilesystem: true only remounts the image-layer root file-system ( / ) as read-only.
      Any separate volume that the kubelet mounts into the container gets its own mount-point and keeps 
      the access mode defined for that volume. Because the fsGroup logic is applied to volumes, those 
      directories are still writable even when the root FS is read-only.
      - Due a known issue with k8s, if runAsNonRoot is set to true, allowPrivilegeEscalation is set to false, even if you
      add Capabilities to the container, the capabilities will not be applied.

  max_retries: 3
  agent: devops_researcher
